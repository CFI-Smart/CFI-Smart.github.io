<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NetRunner — Demo</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#05050a;color:#e6eef8;font-family:Inter,Arial}
  #overlay{position:absolute;left:10px;top:10px;z-index:10}
  .hud {background:rgba(0,0,0,0.35);padding:10px;border-radius:8px;backdrop-filter:blur(4px)}
  #instructions{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);padding:20px;border-radius:10px;text-align:center}
  #minimap{position:absolute;right:10px;top:10px;z-index:10;width:160px;height:160px;background:rgba(0,0,0,0.25);border-radius:8px}
  #message{position:absolute;left:50%;bottom:30px;transform:translateX(-50%);padding:10px 18px;border-radius:6px;background:rgba(0,0,0,0.5)}
  canvas{display:block}
  button{padding:8px 12px;border-radius:6px;border:0;background:#0ea5a4;color:#062b2b;cursor:pointer}
</style>
</head>
<body>
<div id="overlay" class="hud">
  <div>Missão: <span id="mission">Carregando...</span></div>
  <div>XP: <span id="xp">0</span> • Patches: <span id="patches">0</span></div>
  <div style="margin-top:8px"><button id="startBtn">Iniciar (Click para travar cursor)</button></div>
</div>
<div id="minimap" class="hud"></div>
<div id="instructions">
  <h3>NetRunner — Demo</h3>
  <p>W/A/S/D mover • Mouse olhar • 1 = Scanner • 2 = Patch Gun • Espaço pular</p>
  <p>Clique em "Iniciar" para jogar</p>
</div>
<div id="message"></div>

<!-- Three.js CDN -->
<script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.156.0/examples/js/controls/PointerLockControls.js"></script>

<script>
/* ======= Setup básico ======= */
let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let player = {speed:6, pos:new THREE.Vector3(), velocity:new THREE.Vector3(), xp:0, patches:0};

init();
animate();

function init(){
  // cena e câmera
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05050a);
  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0,2,5);

  // renderer
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // luz ambiente + direcional
  scene.add(new THREE.AmbientLight(0xffffff, 0.18));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5,10,7);
  dir.castShadow = true;
  scene.add(dir);

  // chão
  const gFloor = new THREE.PlaneGeometry(200, 200);
  const mFloor = new THREE.MeshStandardMaterial({color:0x091128});
  const floor = new THREE.Mesh(gFloor, mFloor);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  scene.add(floor);

  // malha de prédios simples (procedural)
  const boxGeo = new THREE.BoxGeometry(1,1,1);
  for(let x=-20;x<=20;x+=4){
    for(let z=-20;z<=20;z+=4){
      if(Math.random() < 0.15){
        const h = 1 + Math.random()*6;
        const mat = new THREE.MeshStandardMaterial({color: 0x0b2b3a, metalness:0.2, roughness:0.7});
        const b = new THREE.Mesh(boxGeo.clone().scale(1,h,1), mat);
        b.scale.set(1,h,1);
        b.position.set(x + (Math.random()-0.5)*1.4, h/2, z + (Math.random()-0.5)*1.4);
        b.castShadow = true; b.receiveShadow=true;
        scene.add(b);
      }
    }
  }

  // nodes (servidores)
  window.nodes = [];
  createNodes(18);

  // bots (malware)
  window.bots = [];
  for(let i=0;i<10;i++) spawnBot();

  // controles FPS
  controls = new THREE.PointerLockControls(camera, renderer.domElement);
  document.getElementById('startBtn').addEventListener('click', ()=>{
    controls.lock();
  });

  controls.addEventListener('lock', ()=> document.getElementById('instructions').style.display='none');
  controls.addEventListener('unlock', ()=> document.getElementById('instructions').style.display='block');

  // input
  setupInput();

  // HUD init
  updateHUD();

  // resize
  window.addEventListener('resize', onWindowResize);
}

/* ======= NODES (servidores) ======= */
function createNodes(count){
  const geo = new THREE.SphereGeometry(0.5, 16, 12);
  for(let i=0;i<count;i++){
    const mat = new THREE.MeshStandardMaterial({emissive:0x0033ff, color:0x112244, metalness:0.6, roughness:0.2});
    const m = new THREE.Mesh(geo, mat);
    m.position.set( (Math.random()-0.5)*80, 0.6, (Math.random()-0.5)*80 );
    m.userData = {type:'node', state: 'secure', integrity:100, id:i};
    scene.add(m);
    nodes.push(m);
    // label/marker visual
    const ring = new THREE.Mesh(new THREE.RingGeometry(0.65,0.85,32), new THREE.MeshBasicMaterial({color:0x00ffff, side: THREE.DoubleSide, transparent:true, opacity:0.15}));
    ring.rotation.x = -Math.PI/2;
    ring.position.set(m.position.x,0.01,m.position.z);
    scene.add(ring);
  }
  // infecta alguns
  setTimeout(()=> {
    nodes.slice(0,3).forEach(n => infectNode(n));
    generateMission();
  }, 1000);
}

function infectNode(node){
  node.userData.state = 'infected';
  node.material.emissive.setHex(0xff3300);
}

/* ======= BOTS (malware simples) ======= */
function spawnBot(){
  const g = new THREE.SphereGeometry(0.25, 10, 8);
  const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({emissive:0xff1155, color:0x220011}));
  m.position.set((Math.random()-0.5)*40,0.25,(Math.random()-0.5)*40);
  m.userData = {type:'bot', hp:20, speed: 1+Math.random()*1.8, target:null};
  scene.add(m);
  bots.push(m);
}

/* bot simples: procura o node mais próximo e vai em direção */
function updateBots(dt){
  for(const b of bots){
    // encontra node infectado
    const infected = nodes.filter(n=>n.userData.state==='infected');
    let target = infected.length ? infected[Math.floor(Math.random()*infected.length)] : nodes[Math.floor(Math.random()*nodes.length)];
    if(!target) continue;
    const dir = new THREE.Vector3().subVectors(target.position, b.position);
    const dist = dir.length();
    dir.normalize();
    b.position.addScaledVector(dir, b.userData.speed * dt);
    // colisão simples com player (dano)
    const ppos = camera.position;
    if(b.position.distanceTo(ppos) < 1.0){
      showMessage('Infectado! Perdeu 5 XP');
      player.xp = Math.max(0, player.xp - 5);
      updateHUD();
      // recoloca bot
      b.position.set((Math.random()-0.5)*40,0.25,(Math.random()-0.5)*40);
    }
  }
}

/* ======= MISSÕES ======= */
let currentMission = null;
function generateMission(){
  const infected = nodes.filter(n=>n.userData.state==='infected');
  if(infected.length){
    const target = infected[Math.floor(Math.random()*infected.length)];
    currentMission = {type:'patch_node', targetId: target.userData.id, description: 'Patch no Servidor #' + target.userData.id};
    document.getElementById('mission').innerText = currentMission.description;
  } else {
    document.getElementById('mission').innerText = 'Todas seguras — explore';
    currentMission = null;
  }
}

/* ======= INPUT e AÇÕES ======= */
const keys = {};
function setupInput(){
  document.addEventListener('keydown', (e) => { keys[e.code] = true;
    if(e.code === 'Digit1') useScanner(); 
    if(e.code === 'Digit2') usePatchGun();
  });
  document.addEventListener('keyup', (e) => { keys[e.code] = false; });
}

function useScanner(){
  // varre à frente e pinta nodes próximos
  showMessage('Scanner ativo — procurando vulnerabilidades...');
  const ray = new THREE.Raycaster();
  ray.set(camera.getWorldPosition(new THREE.Vector3()), camera.getWorldDirection(new THREE.Vector3()));
  const hits = ray.intersectObjects(nodes, false);
  if(hits.length){
    const n = hits[0].object;
    showMessage('Servidor #' + n.userData.id + ' — estado: ' + n.userData.state);
  } else showMessage('Nenhum servidor à vista');
}

function usePatchGun(){
  // tenta "patch" no node à frente
  const ray = new THREE.Raycaster();
  ray.set(camera.getWorldPosition(new THREE.Vector3()), camera.getWorldDirection(new THREE.Vector3()));
  const hits = ray.intersectObjects(nodes, false);
  if(hits.length){
    const n = hits[0].object;
    if(n.userData.state === 'infected'){
      // cura
      n.userData.state = 'secure';
      n.material.emissive.setHex(0x0033ff);
      showMessage('Patch aplicado no Servidor #' + n.userData.id + '! +20 XP');
      player.xp += 20;
      player.patches += 1;
      updateHUD();
      generateMission();
    } else {
      showMessage('Servidor não infectado.');
    }
  } else {
    showMessage('Nenhum alvo para patch.');
  }
}

/* ======= HUD, mensagens e minimap simples ======= */
let msgTimer = null;
function showMessage(t){
  const el = document.getElementById('message');
  el.innerText = t;
  el.style.opacity = '1';
  clearTimeout(msgTimer);
  msgTimer = setTimeout(()=> el.style.opacity='0', 2500);
}

function updateHUD(){
  document.getElementById('xp').innerText = player.xp;
  document.getElementById('patches').innerText = player.patches;
  // minimap draw
  const mm = document.getElementById('minimap');
  mm.innerHTML = '';
  const sz = 140;
  const c = document.createElement('canvas');
  c.width = c.height = sz;
  mm.appendChild(c);
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#04121a'; ctx.fillRect(0,0,sz,sz);
  // center is player pos in map coords
  for(const n of nodes){
    const nx = (n.position.x/100)*sz + sz/2;
    const ny = (n.position.z/100)*sz + sz/2;
    ctx.beginPath();
    ctx.arc(nx, ny, 4, 0, Math.PI*2);
    ctx.fillStyle = n.userData.state==='infected' ? '#ff5566' : '#33ffee';
    ctx.fill();
  }
  for(const b of bots){
    const bx = (b.position.x/100)*sz + sz/2;
    const by = (b.position.z/100)*sz + sz/2;
    ctx.fillStyle = '#ffcc33';
    ctx.fillRect(bx-2,by-2,4,4);
  }
}

/* ======= Loop e física simples ======= */
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());
  // movimento básico do player (sem física completa)
  if(controls.isLocked){
    const forward = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
    const side = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
    const dir = new THREE.Vector3();
    controls.getDirection(dir);
    const right = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
    const move = new THREE.Vector3();
    move.addScaledVector(dir, forward * player.speed * dt);
    move.addScaledVector(right, side * player.speed * dt);
    camera.position.add(move);
  }

  updateBots(dt);
  renderer.render(scene, camera);
}

function onWindowResize(){
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

/* ======= SAVE / LOAD (localStorage) ======= */
function saveProgress(){
  const state = {xp:player.xp, patches:player.patches};
  localStorage.setItem('netrunner_save_v1', JSON.stringify(state));
}
function loadProgress(){
  const s = localStorage.getItem('netrunner_save_v1');
  if(s){
    const st = JSON.parse(s);
    player.xp = st.xp || 0;
    player.patches = st.patches || 0;
    updateHUD();
  }
}
window.addEventListener('beforeunload', saveProgress);
loadProgress();
</script>
</body>
</html>
